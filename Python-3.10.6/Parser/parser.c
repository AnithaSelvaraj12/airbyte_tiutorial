// @generated by pegen.py from python.gram
#include "pegen.h"

#if defined(Py_DEBUG) && defined(Py_BUILD_CORE)
#  define D(x) if (Py_DebugFlag) x;
#else
#  define D(x)
#endif

# define MAXSTACK 6000
static const int n_keyword_lists = 9;
static KeywordToken *reserved_keywords[] = {
    (KeywordToken[]) {{NULL, -1}},
    (KeywordToken[]) {{NULL, -1}},
    (KeywordToken[]) {
        {"if", 510},
        {"in", 518},
        {"as", 520},
        {"is", 530},
        {"or", 531},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"del", 503},
        {"try", 511},
        {"for", 517},
        {"def", 526},
        {"not", 529},
        {"and", 532},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"pass", 502},
        {"from", 514},
        {"elif", 515},
        {"else", 516},
        {"with", 519},
        {"None", 523},
        {"True", 524},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"raise", 501},
        {"yield", 504},
        {"break", 506},
        {"while", 512},
        {"False", 525},
        {"class", 527},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"return", 500},
        {"assert", 505},
        {"global", 508},
        {"import", 513},
        {"except", 521},
        {"lambda", 528},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"finally", 522},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"continue", 507},
        {"nonlocal", 509},
        {NULL, -1},
    },
};
static char *soft_keywords[] = {
    "_",
    "case",
    "match",
    NULL,
};
#define file_type 1000
#define interactive_type 1001
#define eval_type 1002
#define func_type_type 1003
#define fstring_type 1004
#define type_expressions_type 1005
#define statements_type 1006
#define statement_type 1007
#define statement_newline_type 1008
#define simple_stmts_type 1009
#define simple_stmt_type 1010
#define compound_stmt_type 1011
#define assignment_type 1012
#define augassign_type 1013
#define global_stmt_type 1014
#define nonlocal_stmt_type 1015
#define yield_stmt_type 1016
#define assert_stmt_type 1017
#define del_stmt_type 1018
#define import_stmt_type 1019
#define import_name_type 1020
#define import_from_type 1021
#define import_from_targets_type 1022
#define import_from_as_names_type 1023
#define import_from_as_name_type 1024
#define dotted_as_names_type 1025
#define dotted_as_name_type 1026
#define dotted_name_type 1027  // Left-recursive
#define if_stmt_type 1028
#define elif_stmt_type 1029
#define else_block_type 1030
#define while_stmt_type 1031
#define for_stmt_type 1032
#define with_stmt_type 1033
#define with_item_type 1034
#define try_stmt_type 1035
#define except_block_type 1036
#define finally_block_type 1037
#define match_stmt_type 1038
#define subject_expr_type 1039
#define case_block_type 1040
#define guard_type 1041
#define patterns_type 1042
#define pattern_type 1043
#define as_pattern_type 1044
#define or_pattern_type 1045
#define closed_pattern_type 1046
#define literal_pattern_type 1047
#define literal_expr_type 1048
#define complex_number_type 1049
#define signed_number_type 1050
#define signed_real_number_type 1051
#define real_number_type 1052
#define imaginary_number_type 1053
#define capture_pattern_type 1054
#define pattern_capture_target_type 1055
#define wildcard_pattern_type 1056
#define value_pattern_type 1057
#define attr_type 1058  // Left-recursive
#define name_or_attr_type 1059  // Left-recursive
#define group_pattern_type 1060
#define sequence_pattern_type 1061
#define open_sequence_pattern_type 1062
#define maybe_sequence_pattern_type 1063
#define maybe_star_pattern_type 1064
#define star_pattern_type 1065
#define mapping_pattern_type 1066
#define items_pattern_type 1067
#define key_value_pattern_type 1068
#define double_star_pattern_type 1069
#define class_pattern_type 1070
#define positional_patterns_type 1071
#define keyword_patterns_type 1072
#define keyword_pattern_type 1073
#define return_stmt_type 1074
#define raise_stmt_type 1075
#define function_def_type 1076
#define function_def_raw_type 1077
#define func_type_comment_type 1078
#define params_type 1079
#define parameters_type 1080
#define slash_no_default_type 1081
#define slash_with_default_type 1082
#define star_etc_type 1083
#define kwds_type 1084
#define param_no_default_type 1085
#define param_with_default_type 1086
#define param_maybe_default_type 1087
#define param_type 1088
#define annotation_type 1089
#define default_type 1090
#define decorators_type 1091
#define class_def_type 1092
#define class_def_raw_type 1093
#define block_type 1094
#define star_expressions_type 1095
#define star_expression_type 1096
#define star_named_expressions_type 1097
#define star_named_expression_type 1098
#define assignment_expression_type 1099
#define named_expression_type 1100
#define annotated_rhs_type 1101
#define expressions_type 1102
#define expression_type 1103
#define lambdef_type 1104
#define lambda_params_type 1105
#define lambda_parameters_type 1106
#define lambda_slash_no_default_type 1107
#define lambda_slash_with_default_type 1108
#define lambda_star_etc_type 1109
#define lambda_kwds_type 1110
#define lambda_param_no_default_type 1111
#define lambda_param_with_default_type 1112
#define lambda_param_maybe_default_type 1113
#define lambda_param_type 1114
#define disjunction_type 1115
#define conjunction_type 1116
#define inversion_type 1117
#define comparison_type 1118
#define compare_op_bitwise_or_pair_type 1119
#define eq_bitwise_or_type 1120
#define noteq_bitwise_or_type 1121
#define lte_bitwise_or_type 1122
#define lt_bitwise_or_type 1123
#define gte_bitwise_or_type 1124
#define gt_bitwise_or_type 1125
#define notin_bitwise_or_type 1126
#define in_bitwise_or_type 1127
#define isnot_bitwise_or_type 1128
#define is_bitwise_or_type 1129
#define bitwise_or_type 1130  // Left-recursive
#define bitwise_xor_type 1131  // Left-recursive
#define bitwise_and_type 1132  // Left-recursive
#define shift_expr_type 1133  // Left-recursive
#define sum_type 1134  // Left-recursive
#define term_type 1135  // Left-recursive
#define factor_type 1136
#define power_type 1137
#define await_primary_type 1138
#define primary_type 1139  // Left-recursive
#define slices_type 1140
#define slice_type 1141
#define atom_type 1142
#define strings_type 1143
#define list_type 1144
#define listcomp_type 1145
#define tuple_type 1146
#define group_type 1147
#define genexp_type 1148
#define set_type 1149
#define setcomp_type 1150
#define dict_type 1151
#define dictcomp_type 1152
#define double_starred_kvpairs_type 1153
#define double_starred_kvpair_type 1154
#define kvpair_type 1155
#define for_if_clauses_type 1156
#define for_if_clause_type 1157
#define yield_expr_type 1158
#define arguments_type 1159
#define args_type 1160
#define kwargs_type 1161
#define starred_expression_type 1162
#define kwarg_or_starred_type 1163
#define kwarg_or_double_starred_type 1164
#define star_targets_type 1165
#define star_targets_list_seq_type 1166
#define star_targets_tuple_seq_type 1167
#define star_target_type 1168
#define target_with_star_atom_type 1169
#define star_atom_type 1170
#define single_target_type 1171
#define single_subscript_attribute_target_type 1172
#define del_targets_type 1173
#define del_target_type 1174
#define del_t_atom_type 1175
#define t_primary_type 1176  // Left-recursive
#define t_lookahead_type 1177
#define invalid_arguments_type 1178
#define invalid_kwarg_type 1179
#define expression_without_invalid_type 1180
#define invalid_legacy_expression_type 1181
#define invalid_expression_type 1182
#define invalid_named_expression_type 1183
#define invalid_assignment_type 1184
#define invalid_ann_assign_target_type 1185
#define invalid_del_stmt_type 1186
#define invalid_block_type 1187
#define invalid_comprehension_type 1188
#define invalid_dict_comprehension_type 1189
#define invalid_parameters_type 1190
#define invalid_parameters_helper_type 1191
#define invalid_lambda_parameters_type 1192
#define invalid_lambda_parameters_helper_type 1193
#define invalid_star_etc_type 1194
#define invalid_lambda_star_etc_type 1195
#define invalid_double_type_comments_type 1196
#define invalid_with_item_type 1197
#define invalid_for_target_type 1198
#define invalid_group_type 1199
#define invalid_import_from_targets_type 1200
#define invalid_with_stmt_type 1201
#define invalid_with_stmt_indent_type 1202
#define invalid_try_stmt_type 1203
#define invalid_except_stmt_type 1204
#define invalid_finally_stmt_type 1205
#define invalid_except_stmt_indent_type 1206
#define invalid_match_stmt_type 1207
#define invalid_case_block_type 1208
#define invalid_as_pattern_type 1209
#define invalid_class_pattern_type 1210
#define invalid_class_argument_pattern_type 1211
#define invalid_if_stmt_type 1212
#define invalid_elif_stmt_type 1213
#define invalid_else_stmt_type 1214
#define invalid_while_stmt_type 1215
#define invalid_for_stmt_type 1216
#define invalid_def_raw_type 1217
#define invalid_class_def_raw_type 1218
#define invalid_double_starred_kvpairs_type 1219
#define invalid_kvpair_type 1220
#define _loop0_1_type 1221
#define _loop0_2_type 1222
#define _loop0_4_type 1223
#define _gather_3_type 1224
#define _loop0_6_type 1225
#define _gather_5_type 1226
#define _loop0_8_type 1227
#define _gather_7_type 1228
#define _loop0_10_type 1229
#define _gather_9_type 1230
#define _loop1_11_type 1231
#define _loop0_13_type 1232
#define _gather_12_type 1233
#define _tmp_14_type 1234
#define _tmp_15_type 1235
#define _tmp_16_type 1236
#define _tmp_17_type 1237
#define _tmp_18_type 1238
#define _tmp_19_type 1239
#define _tmp_20_type 1240
#define _tmp_21_type 1241
#define _loop1_22_type 1242
#define _tmp_23_type 1243
#define _tmp_24_type 1244
#define _loop0_26_type 1245
#define _gather_25_type 1246
#define _loop0_28_type 1247
#define _gather_27_type 1248
#define _tmp_29_type 1249
#define _tmp_30_type 1250
#define _loop0_31_type 1251
#define _loop1_32_type 1252
#define _loop0_34_type 1253
#define _gather_33_type 1254
#define _tmp_35_type 1255
#define _loop0_37_type 1256
#define _gather_36_type 1257
#define _tmp_38_type 1258
#define _loop0_40_type 1259
#define _gather_39_type 1260
#define _loop0_42_type 1261
#define _gather_41_type 1262
#define _loop0_44_type 1263
#define _gather_43_type 1264
#define _loop0_46_type 1265
#define _gather_45_type 1266
#define _tmp_47_type 1267
#define _loop1_48_type 1268
#define _tmp_49_type 1269
#define _loop1_50_type 1270
#define _loop0_52_type 1271
#define _gather_51_type 1272
#define _tmp_53_type 1273
#define _tmp_54_type 1274
#define _tmp_55_type 1275
#define _tmp_56_type 1276
#define _loop0_58_type 1277
#define _gather_57_type 1278
#define _loop0_60_type 1279
#define _gather_59_type 1280
#define _tmp_61_type 1281
#define _loop0_63_type 1282
#define _gather_62_type 1283
#define _loop0_65_type 1284
#define _gather_64_type 1285
#define _tmp_66_type 1286
#define _tmp_67_type 1287
#define _tmp_68_type 1288
#define _tmp_69_type 1289
#define _loop0_70_type 1290
#define _loop0_71_type 1291
#define _loop0_72_type 1292
#define _loop1_73_type 1293
#define _loop0_74_type 1294
#define _loop1_75_type 1295
#define _loop1_76_type 1296
#define _loop1_77_type 1297
#define _loop0_78_type 1298
#define _loop1_79_type 1299
#define _loop0_80_type 1300
#define _loop1_81_type 1301
#define _loop0_82_type 1302
#define _loop1_83_type 1303
#define _loop1_84_type 1304
#define _tmp_85_type 1305
#define _loop1_86_type 1306
#define _loop0_88_type 1307
#define _gather_87_type 1308
#define _loop1_89_type 1309
#define _loop0_90_type 1310
#define _loop0_91_type 1311
#define _loop0_92_type 1312
#define _loop1_93_type 1313
#define _loop0_94_type 1314
#define _loop1_95_type 1315
#define _loop1_96_type 1316
#define _loop1_97_type 1317
#define _loop0_98_type 1318
#define _loop1_99_type 1319
#define _loop0_100_type 1320
#define _loop1_101_type 1321
#define _loop0_102_type 1322
#define _loop1_103_type 1323
#define _loop1_104_type 1324
#define _loop1_105_type 1325
#define _loop1_106_type 1326
#define _tmp_107_type 1327
#define _loop0_109_type 1328
#define _gather_108_type 1329
#define _tmp_110_type 1330
#define _tmp_111_type 1331
#define _tmp_112_type 1332
#define _tmp_113_type 1333
#define _loop1_114_type 1334
#define _tmp_115_type 1335
#define _tmp_116_type 1336
#define _tmp_117_type 1337
#define _loop0_119_type 1338
#define _gather_118_type 1339
#define _loop1_120_type 1340
#define _loop0_121_type 1341
#define _loop0_122_type 1342
#define _loop0_124_type 1343
#define _gather_123_type 1344
#define _tmp_125_type 1345
#define _loop0_127_type 1346
#define _gather_126_type 1347
#define _loop0_129_type 1348
#define _gather_128_type 1349
#define _loop0_131_type 1350
#define _gather_130_type 1351
#define _loop0_133_type 1352
#define _gather_132_type 1353
#define _loop0_134_type 1354
#define _loop0_136_type 1355
#define _gather_135_type 1356
#define _loop1_137_type 1357
#define _tmp_138_type 1358
#define _loop0_140_type 1359
#define _gather_139_type 1360
#define _tmp_141_type 1361
#define _tmp_142_type 1362
#define _tmp_143_type 1363
#define _tmp_144_type 1364
#define _tmp_145_type 1365
#define _tmp_146_type 1366
#define _tmp_147_type 1367
#define _tmp_148_type 1368
#define _loop0_149_type 1369
#define _loop0_150_type 1370
#define _loop0_151_type 1371
#define _tmp_152_type 1372
#define _tmp_153_type 1373
#define _tmp_154_type 1374
#define _tmp_155_type 1375
#define _loop0_156_type 1376
#define _loop1_157_type 1377
#define _loop0_158_type 1378
#define _loop1_159_type 1379
#define _tmp_160_type 1380
#define _tmp_161_type 1381
#define _tmp_162_type 1382
#define _loop0_164_type 1383
#define _gather_163_type 1384
#define _loop0_166_type 1385
#define _gather_165_type 1386
#define _loop0_168_type 1387
#define _gather_167_type 1388
#define _loop0_170_type 1389
#define _gather_169_type 1390
#define _tmp_171_type 1391
#define _tmp_172_type 1392
#define _tmp_173_type 1393
#define _tmp_174_type 1394
#define _tmp_175_type 1395
#define _tmp_176_type 1396
#define _tmp_177_type 1397
#define _tmp_178_type 1398
#define _loop0_180_type 1399
#define _gather_179_type 1400
#define _tmp_181_type 1401
#define _tmp_182_type 1402
#define _tmp_183_type 1403
#define _tmp_184_type 1404
#define _tmp_185_type 1405
#define _tmp_186_type 1406
#define _tmp_187_type 1407
#define _tmp_188_type 1408
#define _tmp_189_type 1409
#define _tmp_190_type 1410
#define _tmp_191_type 1411
#define _tmp_192_type 1412
#define _tmp_193_type 1413
#define _tmp_194_type 1414
#define _tmp_195_type 1415
#define _tmp_196_type 1416
#define _tmp_197_type 1417
#define _tmp_198_type 1418
#define _tmp_199_type 1419
#define _tmp_200_type 1420
#define _tmp_201_type 1421
#define _tmp_202_type 1422
#define _tmp_203_type 1423
#define _tmp_204_type 1424
#define _tmp_205_type 1425
#define _tmp_206_type 1426
#define _tmp_207_type 1427
#define _tmp_208_type 1428

static mod_ty file_rule(Parser *p);
static mod_ty interactive_rule(Parser *p);
static mod_ty eval_rule(Parser *p);
static mod_ty func_type_rule(Parser *p);
static expr_ty fstring_rule(Parser *p);
static asdl_expr_seq* type_expressions_rule(Parser *p);
static asdl_stmt_seq* statements_rule(Parser *p);
static asdl_stmt_seq* statement_rule(Parser *p);
static asdl_stmt_seq* statement_newline_rule(Parser *p);
static asdl_stmt_seq* simple_stmts_rule(Parser *p);
static stmt_ty simple_stmt_rule(Parser *p);
static stmt_ty compound_stmt_rule(Parser *p);
static stmt_ty assignment_rule(Parser *p);
static AugOperator* augassign_rule(Parser *p);
static stmt_ty global_stmt_rule(Parser *p);
static stmt_ty nonlocal_stmt_rule(Parser *p);
static stmt_ty yield_stmt_rule(Parser *p);
static stmt_ty assert_stmt_rule(Parser *p);
static stmt_ty del_stmt_rule(Parser *p);
static stmt_ty import_stmt_rule(Parser *p);
static stmt_ty import_name_rule(Parser *p);
static stmt_ty import_from_rule(Parser *p);
static asdl_alias_seq* import_from_targets_rule(Parser *p);
static asdl_alias_seq* import_from_as_names_rule(Parser *p);
static alias_ty import_from_as_name_rule(Parser *p);
static asdl_alias_seq* dotted_as_names_rule(Parser *p);
static alias_ty dotted_as_name_rule(Parser *p);
static expr_ty dotted_name_rule(Parser *p);
static stmt_ty if_stmt_rule(Parser *p);
static stmt_ty elif_stmt_rule(Parser *p);
static asdl_stmt_seq* else_block_rule(Parser *p);
static stmt_ty while_stmt_rule(Parser *p);
static stmt_ty for_stmt_rule(Parser *p);
static stmt_ty with_stmt_rule(Parser *p);
static withitem_ty with_item_rule(Parser *p);
static stmt_ty try_stmt_rule(Parser *p);
static excepthandler_ty except_block_rule(Parser *p);
static asdl_stmt_seq* finally_block_rule(Parser *p);
static stmt_ty match_stmt_rule(Parser *p);
static expr_ty subject_expr_rule(Parser *p);
static match_case_ty case_block_rule(Parser *p);
static expr_ty guard_rule(Parser *p);
static pattern_ty patterns_rule(Parser *p);
static pattern_ty pattern_rule(Parser *p);
static pattern_ty as_pattern_rule(Parser *p);
static pattern_ty or_pattern_rule(Parser *p);
static pattern_ty closed_pattern_rule(Parser *p);
static pattern_ty literal_pattern_rule(Parser *p);
static expr_ty literal_expr_rule(Parser *p);
static expr_ty complex_number_rule(Parser *p);
static expr_ty signed_number_rule(Parser *p);
static expr_ty signed_real_number_rule(Parser *p);
static expr_ty real_number_rule(Parser *p);
static expr_ty imaginary_number_rule(Parser *p);
static pattern_ty capture_pattern_rule(Parser *p);
static expr_ty pattern_capture_target_rule(Parser *p);
static pattern_ty wildcard_pattern_rule(Parser *p);
static pattern_ty value_pattern_rule(Parser *p);
static expr_ty attr_rule(Parser *p);
static expr_ty name_or_attr_rule(Parser *p);
static pattern_ty group_pattern_rule(Parser *p);
static pattern_ty sequence_pattern_rule(Parser *p);
static asdl_seq* open_sequence_pattern_rule(Parser *p);
static asdl_seq* maybe_sequence_pattern_rule(Parser *p);
static pattern_ty maybe_star_pattern_rule(Parser *p);
static pattern_ty star_pattern_rule(Parser *p);
static pattern_ty mapping_pattern_rule(Parser *p);
static asdl_seq* items_pattern_rule(Parser *p);
static KeyPatternPair* key_value_pattern_rule(Parser *p);
static expr_ty double_star_pattern_rule(Parser *p);
static pattern_ty class_pattern_rule(Parser *p);
static asdl_pattern_seq* positional_patterns_rule(Parser *p);
static asdl_seq* keyword_patterns_rule(Parser *p);
static KeyPatternPair* keyword_pattern_rule(Parser *p);
static stmt_ty return_stmt_rule(Parser *p);
static stmt_ty raise_stmt_rule(Parser *p);
static stmt_ty function_def_rule(Parser *p);
static stmt_ty function_def_raw_rule(Parser *p);
static Token* func_type_comment_rule(Parser *p);
static arguments_ty params_rule(Parser *p);
static arguments_ty parameters_rule(Parser *p);
static asdl_arg_seq* slash_no_default_rule(Parser *p);
static SlashWithDefault* slash_with_default_rule(Parser *p);
static StarEtc* star_etc_rule(Parser *p);
static arg_ty kwds_rule(Parser *p);
static arg_ty param_no_default_rule(Parser *p);
static NameDefaultPair* param_with_default_rule(Parser *p);
static NameDefaultPair* param_maybe_default_rule(Parser *p);
static arg_ty param_rule(Parser *p);
static expr_ty annotation_rule(Parser *p);
static expr_ty default_rule(Parser *p);
static asdl_expr_seq* decorators_rule(Parser *p);
static stmt_ty class_def_rule(Parser *p);
static stmt_ty class_def_raw_rule(Parser *p);
static asdl_stmt_seq* block_rule(Parser *p);
static expr_ty star_expressions_rule(Parser *p);
static expr_ty star_expression_rule(Parser *p);
static asdl_expr_seq* star_named_expressions_rule(Parser *p);
static expr_ty star_named_expression_rule(Parser *p);
static expr_ty assignment_expression_rule(Parser *p);
static expr_ty named_expression_rule(Parser *p);
static expr_ty annotated_rhs_rule(Parser *p);
static expr_ty expressions_rule(Parser *p);
static expr_ty expression_rule(Parser *p);
static expr_ty lambdef_rule(Parser *p);
static arguments_ty lambda_params_rule(Parser *p);
static arguments_ty lambda_parameters_rule(Parser *p);
static asdl_arg_seq* lambda_slash_no_default_rule(Parser *p);
static SlashWithDefault* lambda_slash_with_default_rule(Parser *p);
static StarEtc* lambda_star_etc_rule(Parser *p);
static arg_ty lambda_kwds_rule(Parser *p);
static arg_ty lambda_param_no_default_rule(Parser *p);
static NameDefaultPair* lambda_param_with_default_rule(Parser *p);
static NameDefaultPair* lambda_param_maybe_default_rule(Parser *p);
static arg_ty lambda_param_rule(Parser *p);
static expr_ty disjunction_rule(Parser *p);
static expr_ty conjunction_rule(Parser *p);
static expr_ty inversion_rule(Parser *p);
static expr_ty comparison_rule(Parser *p);
static CmpopExprPair* compare_op_bitwise_or_pair_rule(Parser *p);
static CmpopExprPair* eq_bitwise_or_rule(Parser *p);
static CmpopExprPair* noteq_bitwise_or_rule(Parser *p);
static CmpopExprPair* lte_bitwise_or_rule(Parser *p);
static CmpopExprPair* lt_bitwise_or_rule(Parser *p);
static CmpopExprPair* gte_bitwise_or_rule(Parser *p);
static CmpopExprPair* gt_bitwise_or_rule(Parser *p);
static CmpopExprPair* notin_bitwise_or_rule(Parser *p);
static CmpopExprPair* in_bitwise_or_rule(Parser *p);
static CmpopExprPair* isnot_bitwise_or_rule(Parser *p);
static CmpopExprPair* is_bitwise_or_rule(Parser *p);
static expr_ty bitwise_or_rule(Parser *p);
static expr_ty bitwise_xor_rule(Parser *p);
static expr_ty bitwise_and_rule(Parser *p);
static expr_ty shift_expr_rule(Parser *p);
static expr_ty sum_rule(Parser *p);
static expr_ty term_rule(Parser *p);
static expr_ty factor_rule(Parser *p);
static expr_ty power_rule(Parser *p);
static expr_ty await_primary_rule(Parser *p);
static expr_ty primary_rule(Parser *p);
static expr_ty slices_rule(Parser *p);
static expr_ty slice_rule(Parser *p);
static expr_ty atom_rule(Parser *p);
static expr_ty strings_rule(Parser *p);
static expr_ty list_rule(Parser *p);
static expr_ty listcomp_rule(Parser *p);
static expr_ty tuple_rule(Parser *p);
static expr_ty group_rule(Parser *p);
static expr_ty genexp_rule(Parser *p);
static expr_ty set_rule(Parser *p);
static expr_ty setcomp_rule(Parser *p);
static expr_ty dict_rule(Parser *p);
static expr_ty dictcomp_rule(Parser *p);
static asdl_seq* double_starred_kvpairs_rule(Parser *p);
static KeyValuePair* double_starred_kvpair_rule(Parser *p);
static KeyValuePair* kvpair_rule(Parser *p);
static asdl_comprehension_seq* for_if_clauses_rule(Parser *p);
static comprehension_ty for_if_clause_rule(Parser *p);
static expr_ty yield_expr_rule(Parser *p);
static expr_ty arguments_rule(Parser *p);
static expr_ty args_rule(Parser *p);
static asdl_seq* kwargs_rule(Parser *p);
static expr_ty starred_expression_rule(Parser *p);
static KeywordOrStarred* kwarg_or_starred_rule(Parser *p);
static KeywordOrStarred* kwarg_or_double_starred_rule(Parser *p);
static expr_ty star_targets_rule(Parser *p);
static asdl_expr_seq* star_targets_list_seq_rule(Parser *p);
static asdl_expr_seq* star_targets_tuple_seq_rule(Parser *p);
static expr_ty star_target_rule(Parser *p);
static expr_ty target_with_star_atom_rule(Parser *p);
static expr_ty star_atom_rule(Parser *p);
static expr_ty single_target_rule(Parser *p);
static expr_ty single_subscript_attribute_target_rule(Parser *p);
static asdl_expr_seq* del_targets_rule(Parser *p);
static expr_ty del_target_rule(Parser *p);
static expr_ty del_t_atom_rule(Parser *p);
static expr_ty t_primary_rule(Parser *p);
static void *t_lookahead_rule(Parser *p);
static void *invalid_arguments_rule(Parser *p);
static void *invalid_kwarg_rule(Parser *p);
static expr_ty expression_without_invalid_rule(Parser *p);
static void *invalid_legacy_expression_rule(Parser *p);
static void *invalid_expression_rule(Parser *p);
static void *invalid_named_expression_rule(Parser *p);
static void *invalid_assignment_rule(Parser *p);
static expr_ty invalid_ann_assign_target_rule(Parser *p);
static void *invalid_del_stmt_rule(Parser *p);
static void *invalid_block_rule(Parser *p);
static void *invalid_comprehension_rule(Parser *p);
static void *invalid_dict_comprehension_rule(Parser *p);
static void *invalid_parameters_rule(Parser *p);
static void *invalid_parameters_helper_rule(Parser *p);
static void *invalid_lambda_parameters_rule(Parser *p);
static void *invalid_lambda_parameters_helper_rule(Parser *p);
static void *invalid_star_etc_rule(Parser *p);
static void *invalid_lambda_star_etc_rule(Parser *p);
static void *invalid_double_type_comments_rule(Parser *p);
static void *invalid_with_item_rule(Parser *p);
static void *invalid_for_target_rule(Parser *p);
static void *invalid_group_rule(Parser *p);
static void *invalid_import_from_targets_rule(Parser *p);
static void *invalid_with_stmt_rule(Parser *p);
static void *invalid_with_stmt_indent_rule(Parser *p);
static void *invalid_try_stmt_rule(Parser *p);
static void *invalid_except_stmt_rule(Parser *p);
static void *invalid_finally_stmt_rule(Parser *p);
static void *invalid_except_stmt_indent_rule(Parser *p);
static void *invalid_match_stmt_rule(Parser *p);
static void *invalid_case_block_rule(Parser *p);
static void *invalid_as_pattern_rule(Parser *p);
static void *invalid_class_pattern_rule(Parser *p);
static asdl_pattern_seq* invalid_class_argument_pattern_rule(Parser *p);
static void *invalid_if_stmt_rule(Parser *p);
static void *invalid_elif_stmt_rule(Parser *p);
static void *invalid_else_stmt_rule(Parser *p);
static void *invalid_while_stmt_rule(Parser *p);
static void *invalid_for_stmt_rule(Parser *p);
static void *invalid_def_raw_rule(Parser *p);
static void *invalid_class_def_raw_rule(Parser *p);
static void *invalid_double_starred_kvpairs_rule(Parser *p);
static void *invalid_kvpair_rule(Parser *p);
static asdl_seq *_loop0_1_rule(Parser *p);
static asdl_seq *_loop0_2_rule(Parser *p);
static asdl_seq *_loop0_4_rule(Parser *p);
static asdl_seq *_gather_3_rule(Parser *p);
static asdl_seq *_loop0_6_rule(Parser *p);
static asdl_seq *_gather_5_rule(Parser *p);
static asdl_seq *_loop0_8_rule(Parser *p);
static asdl_seq *_gather_7_rule(Parser *p);
static asdl_seq *_loop0_10_rule(Parser *p);
static asdl_seq *_gather_9_rule(Parser *p);
static asdl_seq *_loop1_11_rule(Parser *p);
static asdl_seq *_loop0_13_rule(Parser *p);
static asdl_seq *_gather_12_rule(Parser *p);
static void *_tmp_14_rule(Parser *p);
static void *_tmp_15_rule(Parser *p);
static void *_tmp_16_rule(Parser *p);
static void *_tmp_17_rule(Parser *p);
static void *_tmp_18_rule(Parser *p);
static void *_tmp_19_rule(Parser *p);
static void *_tmp_20_rule(Parser *p);
static void *_tmp_21_rule(Parser *p);
static asdl_seq *_loop1_22_rule(Parser *p);
static void *_tmp_23_rule(Parser *p);
static void *_tmp_24_rule(Parser *p);
static asdl_seq *_loop0_26_rule(Parser *p);
static asdl_seq *_gather_25_rule(Parser *p);
static asdl_seq *_loop0_28_rule(Parser *p);
static asdl_seq *_gather_27_rule(Parser *p);
static void *_tmp_29_rule(Parser *p);
static void *_tmp_30_rule(Parser *p);
static asdl_seq *_loop0_31_rule(Parser *p);
static asdl_seq *_loop1_32_rule(Parser *p);
static asdl_seq *_loop0_34_rule(Parser *p);
static asdl_seq *_gather_33_rule(Parser *p);
static void *_tmp_35_rule(Parser *p);
static asdl_seq *_loop0_37_rule(Parser *p);
static asdl_seq *_gather_36_rule(Parser *p);
static void *_tmp_38_rule(Parser *p);
static asdl_seq *_loop0_40_rule(Parser *p);
static asdl_seq *_gather_39_rule(Parser *p);
static asdl_seq *_loop0_42_rule(Parser *p);
static asdl_seq *_gather_41_rule(Parser *p);
static asdl_seq *_loop0_44_rule(Parser *p);
static asdl_seq *_gather_43_rule(Parser *p);
static asdl_seq *_loop0_46_rule(Parser *p);
static asdl_seq *_gather_45_rule(Parser *p);
static void *_tmp_47_rule(Parser *p);
static asdl_seq *_loop1_48_rule(Parser *p);
static void *_tmp_49_rule(Parser *p);
static asdl_seq *_loop1_50_rule(Parser *p);
static asdl_seq *_loop0_52_rule(Parser *p);
static asdl_seq *_gather_51_rule(Parser *p);
static void *_tmp_53_rule(Parser *p);
static void *_tmp_54_rule(Parser *p);
static void *_tmp_55_rule(Parser *p);
static void *_tmp_56_rule(Parser *p);
static asdl_seq *_loop0_58_rule(Parser *p);
static asdl_seq *_gather_57_rule(Parser *p);
static asdl_seq *_loop0_60_rule(Parser *p);
static asdl_seq *_gather_59_rule(Parser *p);
static void *_tmp_61_rule(Parser *p);
static asdl_seq *_loop0_63_rule(Parser *p);
static asdl_seq *_gather_62_rule(Parser *p);
static asdl_seq *_loop0_65_rule(Parser *p);
static asdl_seq *_gather_64_rule(Parser *p);
static void *_tmp_66_rule(Parser *p);
static void *_tmp_67_rule(Parser *p);
static void *_tmp_68_rule(Parser *p);
static void *_tmp_69_rule(Parser *p);
static asdl_seq *_loop0_70_rule(Parser *p);
static asdl_seq *_loop0_71_rule(Parser *p);
static asdl_seq *_loop0_72_rule(Parser *p);
static asdl_seq *_loop1_73_rule(Parser *p);
static asdl_seq *_loop0_74_rule(Parser *p);
static asdl_seq *_loop1_75_rule(Parser *p);
static asdl_seq *_loop1_76_rule(Parser *p);
static asdl_seq *_loop1_77_rule(Parser *p);
static asdl_seq *_loop0_78_rule(Parser *p);
static asdl_seq *_loop1_79_rule(Parser *p);
static asdl_seq *_loop0_80_rule(Parser *p);
static asdl_seq *_loop1_81_rule(Parser *p);
static asdl_seq *_loop0_82_rule(Parser *p);
static asdl_seq *_loop1_83_rule(Parser *p);
static asdl_seq *_loop1_84_rule(Parser *p);
static void *_tmp_85_rule(Parser *p);
static asdl_seq *_loop1_86_rule(Parser *p);
static asdl_seq *_loop0_88_rule(Parser *p);
static asdl_seq *_gather_87_rule(Parser *p);
static asdl_seq *_loop1_89_rule(Parser *p);
static asdl_seq *_loop0_90_rule(Parser *p);
static asdl_seq *_loop0_91_rule(Parser *p);
static asdl_seq *_loop0_92_rule(Parser *p);
static asdl_seq *_loop1_93_rule(Parser *p);
static asdl_seq *_loop0_94_rule(Parser *p);
static asdl_seq *_loop1_95_rule(Parser *p);
static asdl_seq *_loop1_96_rule(Parser *p);
static asdl_seq *_loop1_97_rule(Parser *p);
static asdl_seq *_loop0_98_rule(Parser *p);
static asdl_seq *_loop1_99_rule(Parser *p);
static asdl_seq *_loop0_100_rule(Parser *p);
static asdl_seq *_loop1_101_rule(Parser *p);
static asdl_seq *_loop0_102_rule(Parser *p);
static asdl_seq *_loop1_103_rule(Parser *p);
static asdl_seq *_loop1_104_rule(Parser *p);
static asdl_seq *_loop1_105_rule(Parser *p);
static asdl_seq *_loop1_106_rule(Parser *p);
static void *_tmp_107_rule(Parser *p);
static asdl_seq *_loop0_109_rule(Parser *p);
static asdl_seq *_gather_108_rule(Parser *p);
static void *_tmp_110_rule(Parser *p);
static void *_tmp_111_rule(Parser *p);
static void *_tmp_112_rule(Parser *p);
static void *_tmp_113_rule(Parser *p);
static asdl_seq *_loop1_114_rule(Parser *p);
static void *_tmp_115_rule(Parser *p);
static void *_tmp_116_rule(Parser *p);
static void *_tmp_117_rule(Parser *p);
static asdl_seq *_loop0_119_rule(Parser *p);
static asdl_seq *_gather_118_rule(Parser *p);
static asdl_seq *_loop1_120_rule(Parser *p);
static asdl_seq *_loop0_121_rule(Parser *p);
static asdl_seq *_loop0_122_rule(Parser *p);
static asdl_seq *_loop0_124_rule(Parser *p);
static asdl_seq *_gather_123_rule(Parser *p);
static void *_tmp_125_rule(Parser *p);
static asdl_seq *_loop0_127_rule(Parser *p);
static asdl_seq *_gather_126_rule(Parser *p);
static asdl_seq *_loop0_129_rule(Parser *p);
static asdl_seq *_gather_128_rule(Parser *p);
static asdl_seq *_loop0_131_rule(Parser *p);
static asdl_seq *_gather_130_rule(Parser *p);
static asdl_seq *_loop0_133_rule(Parser *p);
static asdl_seq *_gather_132_rule(Parser *p);
static asdl_seq *_loop0_134_rule(Parser *p);
static asdl_seq *_loop0_136_rule(Parser *p);
static asdl_seq *_gather_135_rule(Parser *p);
static asdl_seq *_loop1_137_rule(Parser *p);
static void *_tmp_138_rule(Parser *p);
static asdl_seq *_loop0_140_rule(Parser *p);
static asdl_seq *_gather_139_rule(Parser *p);
static void *_tmp_141_rule(Parser *p);
static void *_tmp_142_rule(Parser *p);
static void *_tmp_143_rule(Parser *p);
static void *_tmp_144_rule(Parser *p);
static void *_tmp_145_rule(Parser *p);
static void *_tmp_146_rule(Parser *p);
static void *_tmp_147_rule(Parser *p);
static void *_tmp_148_rule(Parser *p);
static asdl_seq *_loop0_149_rule(Parser *p);
static asdl_seq *_loop0_150_rule(Parser *p);
static asdl_seq *_loop0_151_rule(Parser *p);
static void *_tmp_152_rule(Parser *p);
static void *_tmp_153_rule(Parser *p);
static void *_tmp_154_rule(Parser *p);
static void *_tmp_155_rule(Parser *p);
static asdl_seq *_loop0_156_rule(Parser *p);
static asdl_seq *_loop1_157_rule(Parser *p);
static asdl_seq *_loop0_158_rule(Parser *p);
static asdl_seq *_loop1_159_rule(Parser *p);
static void *_tmp_160_rule(Parser *p);
static void *_tmp_161_rule(Parser *p);
static void *_tmp_162_rule(Parser *p);
static asdl_seq *_loop0_164_rule(Parser *p);
static asdl_seq *_gather_163_rule(Parser *p);
static asdl_seq *_loop0_166_rule(Parser *p);
static asdl_seq *_gather_165_rule(Parser *p);
static asdl_seq *_loop0_168_rule(Parser *p);
static asdl_seq *_gather_167_rule(Parser *p);
static asdl_seq *_loop0_170_rule(Parser *p);
static asdl_seq *_gather_169_rule(Parser *p);
static void *_tmp_171_rule(Parser *p);
static void *_tmp_172_rule(Parser *p);
static void *_tmp_173_rule(Parser *p);
static void *_tmp_174_rule(Parser *p);
static void *_tmp_175_rule(Parser *p);
static void *_tmp_176_rule(Parser *p);
static void *_tmp_177_rule(Parser *p);
static void *_tmp_178_rule(Parser *p);
static asdl_seq *_loop0_180_rule(Parser *p);
static asdl_seq *_gather_179_rule(Parser *p);
static void *_tmp_181_rule(Parser *p);
static void *_tmp_182_rule(Parser *p);
static void *_tmp_183_rule(Parser *p);
static void *_tmp_184_rule(Parser *p);
static void *_tmp_185_rule(Parser *p);
static void *_tmp_186_rule(Parser *p);
static void *_tmp_187_rule(Parser *p);
static void *_tmp_188_rule(Parser *p);
static void *_tmp_189_rule(Parser *p);
static void *_tmp_190_rule(Parser *p);
static void *_tmp_191_rule(Parser *p);
static void *_tmp_192_rule(Parser *p);
static void *_tmp_193_rule(Parser *p);
static void *_tmp_194_rule(Parser *p);
static void *_tmp_195_rule(Parser *p);
static void *_tmp_196_rule(Parser *p);
static void *_tmp_197_rule(Parser *p);
static void *_tmp_198_rule(Parser *p);
static void *_tmp_199_rule(Parser *p);
static void *_tmp_200_rule(Parser *p);
static void *_tmp_201_rule(Parser *p);
static void *_tmp_202_rule(Parser *p);
static void *_tmp_203_rule(Parser *p);
static void *_tmp_204_rule(Parser *p);
static void *_tmp_205_rule(Parser *p);
static void *_tmp_206_rule(Parser *p);
static void *_tmp_207_rule(Parser *p);
static void *_tmp_208_rule(Parser *p);


// file: statements? $
static mod_ty
file_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // statements? $
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> file[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "statements? $"));
        void *a;
        Token * endmarker_var;
        if (
            (a = statements_rule(p), !p->error_indicator)  // statements?
            &&
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ file[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "statements? $"));
            _res = _PyPegen_make_module ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s file[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "statements? $"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// interactive: statement_newline
static mod_ty
interactive_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // statement_newline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> interactive[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "statement_newline"));
        asdl_stmt_seq* a;
        if (
            (a = statement_newline_rule(p))  // statement_newline
        )
        {
            D(fprintf(stderr, "%*c+ interactive[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "statement_newline"));
            _res = _PyAST_Interactive ( a , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s interactive[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "statement_newline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// eval: expressions NEWLINE* $
static mod_ty
eval_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // expressions NEWLINE* $
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> eval[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expressions NEWLINE* $"));
        asdl_seq * _loop0_1_var;
        expr_ty a;
        Token * endmarker_var;
        if (
            (a = expressions_rule(p))  // expressions
            &&
            (_loop0_1_var = _loop0_1_rule(p))  // NEWLINE*
            &&
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ eval[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expressions NEWLINE* $"));
            _res = _PyAST_Expression ( a , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s eval[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expressions NEWLINE* $"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// func_type: '(' type_expressions? ')' '->' expression NEWLINE* $
static mod_ty
func_type_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // '(' type_expressions? ')' '->' expression NEWLINE* $
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> func_type[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' type_expressions? ')' '->' expression NEWLINE* $"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        asdl_seq * _loop0_2_var;
        void *a;
        expr_ty b;
        Token * endmarker_var;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = type_expressions_rule(p), !p->error_indicator)  // type_expressions?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (_literal_2 = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (b = expression_rule(p))  // expression
            &&
            (_loop0_2_var = _loop0_2_rule(p))  // NEWLINE*
            &&
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ func_type[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' type_expressions? ')' '->' expression NEWLINE* $"));
            _res = _PyAST_FunctionType ( a , b , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s func_type[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' type_expressions? ')' '->' expression NEWLINE* $"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// fstring: star_expressions
static expr_ty
fstring_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> fstring[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_expressions"));
        expr_ty star_expressions_var;
        if (
            (star_expressions_var = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ fstring[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expressions"));
            _res = star_expressions_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s fstring[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_expressions"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// type_expressions:
//     | ','.expression+ ',' '*' expression ',' '**' expression
//     | ','.expression+ ',' '*' expression
//     | ','.expression+ ',' '**' expression
//     | '*' expression ',' '**' expression
//     | '*' expression
//     | '**' expression
//     | ','.expression+
static asdl_expr_seq*
type_expressions_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_expr_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.expression+ ',' '*' expression ',' '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.expression+ ',' '*' expression ',' '**' expression"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        Token * _literal_3;
        asdl_seq * a;
        expr_ty b;
        expr_ty c;
        if (
            (a = _gather_3_rule(p))  // ','.expression+
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_1 = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (b = expression_rule(p))  // expression
            &&
            (_literal_2 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_3 = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (c = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.expression+ ',' '*' expression ',' '**' expression"));
            _res = ( asdl_expr_seq * ) _PyPegen_seq_append_to_end ( p , CHECK ( asdl_seq * , _PyPegen_seq_append_to_end ( p , a , b ) ) , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.expression+ ',' '*' expression ',' '**' expression"));
    }
    { // ','.expression+ ',' '*' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.expression+ ',' '*' expression"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        expr_ty b;
        if (
            (a = _gather_5_rule(p))  // ','.expression+
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_1 = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.expression+ ',' '*' expression"));
            _res = ( asdl_expr_seq * ) _PyPegen_seq_append_to_end ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.expression+ ',' '*' expression"));
    }
    { // ','.expression+ ',' '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.expression+ ',' '**' expression"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        expr_ty b;
        if (
            (a = _gather_7_rule(p))  // ','.expression+
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_1 = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.expression+ ',' '**' expression"));
            _res = ( asdl_expr_seq * ) _PyPegen_seq_append_to_end ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.expression+ ',' '**' expression"));
    }
    { // '*' expression ',' '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' expression ',' '**' expression"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        expr_ty a;
        expr_ty b;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = expression_rule(p))  // expression
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_2 = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' expression ',' '**' expression"));
            _res = ( asdl_expr_seq * ) _PyPegen_seq_append_to_end ( p , CHECK ( asdl_seq * , _PyPegen_singleton_seq ( p , a ) ) , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' expression ',' '**' expression"));
    }
    { // '*' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' expression"));
            _res = ( asdl_expr_seq * ) _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' expression"));
    }
    { // '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'**' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'**' expression"));
            _res = ( asdl_expr_seq * ) _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'**' expression"));
    }
    { // ','.expression+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.expression+"));
        asdl_expr_seq* a;
        if (
            (a = (asdl_expr_seq*)_gather_9_rule(p))  // ','.expression+
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.expression+"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.expression+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// statements: statement+
static asdl_stmt_seq*
statements_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // statement+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statements[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "statement+"));
        asdl_seq * a;
        if (
            (a = _loop1_11_rule(p))  // statement+
        )
        {
            D(fprintf(stderr, "%*c+ statements[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "statement+"));
            _res = ( asdl_stmt_seq * ) _PyPegen_seq_flatten ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statements[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "statement+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// statement: compound_stmt | simple_stmts
static asdl_stmt_seq*
statement_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // compound_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "compound_stmt"));
        stmt_ty a;
        if (
            (a = compound_stmt_rule(p))  // compound_stmt
        )
        {
            D(fprintf(stderr, "%*c+ statement[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "compound_stmt"));
            _res = ( asdl_stmt_seq * ) _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "compound_stmt"));
    }
    { // simple_stmts
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "simple_stmts"));
        asdl_stmt_seq* a;
        if (
            (a = (asdl_stmt_seq*)simple_stmts_rule(p))  // simple_stmts
        )
        {
            D(fprintf(stderr, "%*c+ statement[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "simple_stmts"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "simple_stmts"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// statement_newline: compound_stmt NEWLINE | simple_stmts | NEWLINE | $
static asdl_stmt_seq*
statement_newline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // compound_stmt NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_newline[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "compound_stmt NEWLINE"));
        stmt_ty a;
        Token * newline_var;
        if (
            (a = compound_stmt_rule(p))  // compound_stmt
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ statement_newline[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "compound_stmt NEWLINE"));
            _res = ( asdl_stmt_seq * ) _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_newline[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "compound_stmt NEWLINE"));
    }
    { // simple_stmts
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_newline[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "simple_stmts"));
        asdl_stmt_seq* simple_stmts_var;
        if (
            (simple_stmts_var = simple_stmts_rule(p))  // simple_stmts
        )
        {
            D(fprintf(stderr, "%*c+ statement_newline[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "simple_stmts"));
            _res = simple_stmts_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_newline[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "simple_stmts"));
    }
    { // NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_newline[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NEWLINE"));
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ statement_newline[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NEWLINE"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = ( asdl_stmt_seq * ) _PyPegen_singleton_seq ( p , CHECK ( stmt_ty , _PyAST_Pass ( EXTRA ) ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_newline[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NEWLINE"));
    }
    { // $
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_newline[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "$"));
        Token * endmarker_var;
        if (
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ statement_newline[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "$"));
            _res = _PyPegen_interactive_exit ( p );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_newline[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "$"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// simple_stmts: simple_stmt !';' NEWLINE | ';'.simple_stmt+ ';'? NEWLINE
static asdl_stmt_seq*
simple_stmts_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // simple_stmt !';' NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmts[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "simple_stmt !';' NEWLINE"));
        stmt_ty a;
        Token * newline_var;
        if (
            (a = simple_stmt_rule(p))  // simple_stmt
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 13)  // token=';'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmts[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "simple_stmt !';' NEWLINE"));
            _res = ( asdl_stmt_seq * ) _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmts[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "simple_stmt !';' NEWLINE"));
    }
    { // ';'.simple_stmt+ ';'? NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmts[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "';'.simple_stmt+ ';'? NEWLINE"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_stmt_seq* a;
        Token * newline_var;
        if (
            (a = (asdl_stmt_seq*)_gather_12_rule(p))  // ';'.simple_stmt+
            &&
            (_opt_var = _PyPegen_expect_token(p, 13), !p->error_indicator)  // ';'?
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmts[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "';'.simple_stmt+ ';'? NEWLINE"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmts[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "';'.simple_stmt+ ';'? NEWLINE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// simple_stmt:
//     | assignment
//     | star_expressions
//     | &'return' return_stmt
//     | &('import' | 'from') import_stmt
//     | &'raise' raise_stmt
//     | 'pass'
//     | &'del' del_stmt
//     | &'yield' yield_stmt
//     | &'assert' assert_stmt
//     | 'break'
//     | 'continue'
//     | &'global' global_stmt
//     | &'nonlocal' nonlocal_stmt
static stmt_ty
simple_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    if (_PyPegen_is_memoized(p, simple_stmt_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // assignment
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "assignment"));
        stmt_ty assignment_var;
        if (
            (assignment_var = assignment_rule(p))  // assignment
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "assignment"));
            _res = assignment_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "assignment"));
    }
    { // star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_expressions"));
        expr_ty e;
        if (
            (e = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expressions"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Expr ( e , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_expressions"));
    }
    { // &'return' return_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'return' return_stmt"));
        stmt_ty return_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 500)  // token='return'
            &&
            (return_stmt_var = return_stmt_rule(p))  // return_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'return' return_stmt"));
            _res = return_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'return' return_stmt"));
    }
    { // &('import' | 'from') import_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&('import' | 'from') import_stmt"));
        stmt_ty import_stmt_var;
        if (
            _PyPegen_lookahead(1, _tmp_14_rule, p)
            &&
            (import_stmt_var = import_stmt_rule(p))  // import_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&('import' | 'from') import_stmt"));
            _res = import_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&('import' | 'from') import_stmt"));
    }
    { // &'raise' raise_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'raise' raise_stmt"));
        stmt_ty raise_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 501)  // token='raise'
            &&
            (raise_stmt_var = raise_stmt_rule(p))  // raise_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'raise' raise_stmt"));
            _res = raise_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'raise' raise_stmt"));
    }
    { // 'pass'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'pass'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 502))  // token='pass'
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'pass'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Pass ( EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'pass'"));
    }
    { // &'del' del_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'del' del_stmt"));
        stmt_ty del_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 503)  // token='del'
            &&
            (del_stmt_var = del_stmt_rule(p))  // del_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'del' del_stmt"));
            _res = del_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'del' del_stmt"));
    }
    { // &'yield' yield_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'yield' yield_stmt"));
        stmt_ty yield_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 504)  // token='yield'
            &&
            (yield_stmt_var = yield_stmt_rule(p))  // yield_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'yield' yield_stmt"));
            _res = yield_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'yield' yield_stmt"));
    }
    { // &'assert' assert_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'assert' assert_stmt"));
        stmt_ty assert_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 505)  // token='assert'
            &&
            (assert_stmt_var = assert_stmt_rule(p))  // assert_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'assert' assert_stmt"));
            _res = assert_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'assert' assert_stmt"));
    }
    { // 'break'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'break'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 506))  // token='break'
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'break'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Break ( EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'break'"));
    }
    { // 'continue'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'continue'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 507))  // token='continue'
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'continue'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Continue ( EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'continue'"));
    }
    { // &'global' global_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'global' global_stmt"));
        stmt_ty global_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 508)  // token='global'
            &&
            (global_stmt_var = global_stmt_rule(p))  // global_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'global' global_stmt"));
            _res = global_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'global' global_stmt"));
    }
    { // &'nonlocal' nonlocal_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'nonlocal' nonlocal_stmt"));
        stmt_ty nonlocal_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 509)  // token='nonlocal'
            &&
            (nonlocal_stmt_var = nonlocal_stmt_rule(p))  // nonlocal_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'nonlocal' nonlocal_stmt"));
            _res = nonlocal_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'nonlocal' nonlocal_stmt"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, simple_stmt_type, _res);
    p->level--;
    return _res;
}

// compound_stmt:
//     | &('def' | '@' | ASYNC) function_def
//     | &'if' if_stmt
//     | &('class' | '@') class_def
//     | &('with' | ASYNC) with_stmt
//     | &('for' | ASYNC) for_stmt
//     | &'try' try_stmt
//     | &'while' while_stmt
//     | match_stmt
static stmt_ty
compound_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    { // &('def' | '@' | ASYNC) function_def
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&('def' | '@' | ASYNC) function_def"));
        stmt_ty function_def_var;
        if (
            _PyPegen_lookahead(1, _tmp_15_rule, p)
            &&
            (function_def_var = function_def_rule(p))  // function_def
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&('def' | '@' | ASYNC) function_def"));
            _res = function_def_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&('def' | '@' | ASYNC) function_def"));
    }
    { // &'if' if_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'if' if_stmt"));
        stmt_ty if_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 510)  // token='if'
            &&
            (if_stmt_var = if_stmt_rule(p))  // if_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'if' if_stmt"));
            _res = if_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'if' if_stmt"));
    }
    { // &('class' | '@') class_def
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&('class' | '@') class_def"));
        stmt_ty class_def_var;
        if (
            _PyPegen_lookahead(1, _tmp_16_rule, p)
            &&
            (class_def_var = class_def_rule(p))  // class_def
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&('class' | '@') class_def"));
            _res = class_def_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&('class' | '@') class_def"));
    }
    { // &('with' | ASYNC) with_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&('with' | ASYNC) with_stmt"));
        stmt_ty with_stmt_var;
        if (
            _PyPegen_lookahead(1, _tmp_17_rule, p)
            &&
            (with_stmt_var = with_stmt_rule(p))  // with_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&('with' | ASYNC) with_stmt"));
            _res = with_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&('with' | ASYNC) with_stmt"));
    }
    { // &('for' | ASYNC) for_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&('for' | ASYNC) for_stmt"));
        stmt_ty for_stmt_var;
        if (
            _PyPegen_lookahead(1, _tmp_18_rule, p)
            &&
            (for_stmt_var = for_stmt_rule(p))  // for_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&('for' | ASYNC) for_stmt"));
            _res = for_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&('for' | ASYNC) for_stmt"));
    }
    { // &'try' try_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'try' try_stmt"));
        stmt_ty try_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 511)  // token='try'
            &&
            (try_stmt_var = try_stmt_rule(p))  // try_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'try' try_stmt"));
            _res = try_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'try' try_stmt"));
    }
    { // &'while' while_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'while' while_stmt"));
        stmt_ty while_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 512)  // token='while'
            &&
            (while_stmt_var = while_stmt_rule(p))  // while_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'while' while_stmt"));
            _res = while_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'while' while_stmt"));
    }
    { // match_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "match_stmt"));
        stmt_ty match_stmt_var;
        if (
            (match_stmt_var = match_stmt_rule(p))  // match_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "match_stmt"));
            _res = match_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "match_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// assignment:
//     | NAME ':' expression ['=' annotated_rhs]
//     | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]
//     | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?
//     | single_target augassign ~ (yield_expr | star_expressions)
//     | invalid_assignment
static stmt_ty
assignment_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME ':' expression ['=' annotated_rhs]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME ':' expression ['=' annotated_rhs]"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        void *c;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
            &&
            (c = _tmp_19_rule(p), !p->error_indicator)  // ['=' annotated_rhs]
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME ':' expression ['=' annotated_rhs]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 6 , "Variable annotation syntax is" , _PyAST_AnnAssign ( CHECK ( expr_ty , _PyPegen_set_expr_context ( p , a , Store ) ) , b , c , 1 , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME ':' expression ['=' annotated_rhs]"));
    }
    { // ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]"));
        Token * _literal;
        void *a;
        expr_ty b;
        void *c;
        if (
            (a = _tmp_20_rule(p))  // '(' single_target ')' | single_subscript_attribute_target
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
            &&
            (c = _tmp_21_rule(p), !p->error_indicator)  // ['=' annotated_rhs]
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 6 , "Variable annotations syntax is" , _PyAST_AnnAssign ( a , b , c , 0 , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]"));
    }
    { // ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?"));
        asdl_expr_seq* a;
        void *b;
        void *tc;
        if (
            (a = (asdl_expr_seq*)_loop1_22_rule(p))  // ((star_targets '='))+
            &&
            (b = _tmp_23_rule(p))  // yield_expr | star_expressions
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 22)  // token='='
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Assign ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?"));
    }
    { // single_target augassign ~ (yield_expr | star_expressions)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "single_target augassign ~ (yield_expr | star_expressions)"));
        int _cut_var = 0;
        expr_ty a;
        AugOperator* b;
        void *c;
        if (
            (a = single_target_rule(p))  // single_target
            &&
            (b = augassign_rule(p))  // augassign
            &&
            (_cut_var = 1)
            &&
            (c = _tmp_24_rule(p))  // yield_expr | star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "single_target augassign ~ (yield_expr | star_expressions)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_AugAssign ( a , b -> kind , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "single_target augassign ~ (yield_expr | star_expressions)"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    if (p->call_invalid_rules) { // invalid_assignment
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_assignment"));
        void *invalid_assignment_var;
        if (
            (invalid_assignment_var = invalid_assignment_rule(p))  // invalid_assignment
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_assignment"));
            _res = invalid_assignment_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_assignment"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// augassign:
//     | '+='
//     | '-='
//     | '*='
//     | '@='
//     | '/='
//     | '%='
//     | '&='
//     | '|='
//     | '^='
//     | '<<='
//     | '>>='
//     | '**='
//     | '//='
static AugOperator*
augassign_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    AugOperator* _res = NULL;
    int _mark = p->mark;
    { // '+='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'+='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 36))  // token='+='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'+='"));
            _res = _PyPegen_augoperator ( p , Add );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'+='"));
    }
    { // '-='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'-='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 37))  // token='-='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'-='"));
            _res = _PyPegen_augoperator ( p , Sub );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'-='"));
    }
    { // '*='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 38))  // token='*='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*='"));
            _res = _PyPegen_augoperator ( p , Mult );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*='"));
    }
    { // '@='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'@='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 50))  // token='@='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'@='"));
            _res = CHECK_VERSION ( AugOperator * , 5 , "The '@' operator is" , _PyPegen_augoperator ( p , MatMult ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'@='"));
    }
    { // '/='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'/='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 39))  // token='/='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'/='"));
            _res = _PyPegen_augoperator ( p , Div );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'/='"));
    }
    { // '%='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'%='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 40))  // token='%='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'%='"));
            _res = _PyPegen_augoperator ( p , Mod );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'%='"));
    }
    { // '&='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'&='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 41))  // token='&='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'&='"));
            _res = _PyPegen_augoperator ( p , BitAnd );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'&='"));
    }
    { // '|='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'|='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 42))  // token='|='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'|='"));
            _res = _PyPegen_augoperator ( p , BitOr );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'|='"));
    }
    { // '^='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'^='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 43))  // token='^='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'^='"));
            _res = _PyPegen_augoperator ( p , BitXor );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'^='"));
    }
    { // '<<='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'<<='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 44))  // token='<<='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'<<='"));
            _res = _PyPegen_augoperator ( p , LShift );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'<<='"));
    }
    { // '>>='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'>>='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 45))  // token='>>='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'>>='"));
            _res = _PyPegen_augoperator ( p , RShift );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'>>='"));
    }
    { // '**='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'**='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 46))  // token='**='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'**='"));
            _res = _PyPegen_augoperator ( p , Pow );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'**='"));
    }
    { // '//='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'//='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 48))  // token='//='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'//='"));
            _res = _PyPegen_augoperator ( p , FloorDiv );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'//='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// global_stmt: 'global' ','.NAME+
static stmt_ty
global_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'global' ','.NAME+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> global_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'global' ','.NAME+"));
        Token * _keyword;
        asdl_expr_seq* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 508))  // token='global'
            &&
            (a = (asdl_expr_seq*)_gather_25_rule(p))  // ','.NAME+
        )
        {
            D(fprintf(stderr, "%*c+ global_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'global' ','.NAME+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Global ( CHECK ( asdl_identifier_seq * , _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s global_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'global' ','.NAME+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// nonlocal_stmt: 'nonlocal' ','.NAME+
static stmt_ty
nonlocal_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'nonlocal' ','.NAME+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> nonlocal_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'nonlocal' ','.NAME+"));
        Token * _keyword;
        asdl_expr_seq* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 509))  // token='nonlocal'
            &&
            (a = (asdl_expr_seq*)_gather_27_rule(p))  // ','.NAME+
        )
        {
            D(fprintf(stderr, "%*c+ nonlocal_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'nonlocal' ','.NAME+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Nonlocal ( CHECK ( asdl_identifier_seq * , _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s nonlocal_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'nonlocal' ','.NAME+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// yield_stmt: yield_expr
static stmt_ty
yield_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // yield_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> yield_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "yield_expr"));
        expr_ty y;
        if (
            (y = yield_expr_rule(p))  // yield_expr
        )
        {
            D(fprintf(stderr, "%*c+ yield_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "yield_expr"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Expr ( y , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s yield_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "yield_expr"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// assert_stmt: 'assert' expression [',' expression]
static stmt_ty
assert_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'assert' expression [',' expression]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assert_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'assert' expression [',' expression]"));
        Token * _keyword;
        expr_ty a;
        void *b;
        if (
            (_keyword = _PyPegen_expect_token(p, 505))  // token='assert'
            &&
            (a = expression_rule(p))  // expression
            &&
            (b = _tmp_29_rule(p), !p->error_indicator)  // [',' expression]
        )
        {
            D(fprintf(stderr, "%*c+ assert_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'assert' expression [',' expression]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Assert ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assert_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'assert' expression [',' expression]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt
static stmt_ty
del_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'del' del_targets &(';' | NEWLINE)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'del' del_targets &(';' | NEWLINE)"));
        Token * _keyword;
        asdl_expr_seq* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 503))  // token='del'
            &&
            (a = del_targets_rule(p))  // del_targets
            &&
            _PyPegen_lookahead(1, _tmp_30_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ del_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'del' del_targets &(';' | NEWLINE)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Delete ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'del' del_targets &(';' | NEWLINE)"));
    }
    if (p->call_invalid_rules) { // invalid_del_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_del_stmt"));
        void *invalid_del_stmt_var;
        if (
            (invalid_del_stmt_var = invalid_del_stmt_rule(p))  // invalid_del_stmt
        )
        {
            D(fprintf(stderr, "%*c+ del_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_del_stmt"));
            _res = invalid_del_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_del_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_stmt: import_name | import_from
static stmt_ty
import_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    { // import_name
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "import_name"));
        stmt_ty import_name_var;
        if (
            (import_name_var = import_name_rule(p))  // import_name
        )
        {
            D(fprintf(stderr, "%*c+ import_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "import_name"));
            _res = import_name_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "import_name"));
    }
    { // import_from
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "import_from"));
        stmt_ty import_from_var;
        if (
            (import_from_var = import_from_rule(p))  // import_from
        )
        {
            D(fprintf(stderr, "%*c+ import_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "import_from"));
            _res = import_from_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "import_from"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_name: 'import' dotted_as_names
static stmt_ty
import_name_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'import' dotted_as_names
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_name[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'import' dotted_as_names"));
        Token * _keyword;
        asdl_alias_seq* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 513))  // token='import'
            &&
            (a = dotted_as_names_rule(p))  // dotted_as_names
        )
        {
            D(fprintf(stderr, "%*c+ import_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'import' dotted_as_names"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Import ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_name[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'import' dotted_as_names"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_from:
//     | 'from' (('.' | '...'))* dotted_name 'import' import_from_targets
//     | 'from' (('.' | '...'))+ 'import' import_from_targets
static stmt_ty
import_from_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'from' (('.' | '...'))* dotted_name 'import' import_from_targets
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'from' (('.' | '...'))* dotted_name 'import' import_from_targets"));
        Token * _keyword;
        Token * _keyword_1;
        asdl_seq * a;
        expr_ty b;
        asdl_alias_seq* c;
        if (
            (_keyword = _PyPegen_expect_token(p, 514))  // token='from'
            &&
            (a = _loop0_31_rule(p))  // (('.' | '...'))*
            &&
            (b = dotted_name_rule(p))  // dotted_name
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 513))  // token='import'
            &&
            (c = import_from_targets_rule(p))  // import_from_targets
        )
        {
            D(fprintf(stderr, "%*c+ import_from[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'from' (('.' | '...'))* dotted_name 'import' import_from_targets"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ImportFrom ( b -> v . Name . id , c , _PyPegen_seq_count_dots ( a ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'from' (('.' | '...'))* dotted_name 'import' import_from_targets"));
    }
    { // 'from' (('.' | '...'))+ 'import' import_from_targets
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'from' (('.' | '...'))+ 'import' import_from_targets"));
        Token * _keyword;
        Token * _keyword_1;
        asdl_seq * a;
        asdl_alias_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 514))  // token='from'
            &&
            (a = _loop1_32_rule(p))  // (('.' | '...'))+
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 513))  // token='import'
            &&
            (b = import_from_targets_rule(p))  // import_from_targets
        )
        {
            D(fprintf(stderr, "%*c+ import_from[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'from' (('.' | '...'))+ 'import' import_from_targets"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ImportFrom ( NULL , b , _PyPegen_seq_count_dots ( a ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'from' (('.' | '...'))+ 'import' import_from_targets"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_from_targets:
//     | '(' import_from_as_names ','? ')'
//     | import_from_as_names !','
//     | '*'
//     | invalid_import_from_targets
static asdl_alias_seq*
import_from_targets_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_alias_seq* _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '(' import_from_as_names ','? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_targets[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' import_from_as_names ','? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_alias_seq* a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = import_from_as_names_rule(p))  // import_from_as_names
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ import_from_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' import_from_as_names ','? ')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_targets[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' import_from_as_names ','? ')'"));
    }
    { // import_from_as_names !','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_targets[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "import_from_as_names !','"));
        asdl_alias_seq* import_from_as_names_var;
        if (
            (import_from_as_names_var = import_from_as_names_rule(p))  // import_from_as_names
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 12)  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ import_from_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "import_from_as_names !','"));
            _res = import_from_as_names_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_targets[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "import_from_as_names !','"));
    }
    { // '*'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_targets[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
        )
        {
            D(fprintf(stderr, "%*c+ import_from_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = ( asdl_alias_seq * ) _PyPegen_singleton_seq ( p , CHECK ( alias_ty , _PyPegen_alias_for_star ( p , EXTRA ) ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_targets[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*'"));
    }
    if (p->call_invalid_rules) { // invalid_import_from_targets
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_targets[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_import_from_targets"));
        void *invalid_import_from_targets_var;
        if (
            (invalid_import_from_targets_var = invalid_import_from_targets_rule(p))  // invalid_import_from_targets
        )
        {
            D(fprintf(stderr, "%*c+ import_from_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_import_from_targets"));
            _res = invalid_import_from_targets_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_targets[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_import_from_targets"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_from_as_names: ','.import_from_as_name+
static asdl_alias_seq*
import_from_as_names_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_alias_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.import_from_as_name+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_as_names[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.import_from_as_name+"));
        asdl_alias_seq* a;
        if (
            (a = (asdl_alias_seq*)_gather_33_rule(p))  // ','.import_from_as_name+
        )
        {
            D(fprintf(stderr, "%*c+ import_from_as_names[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.import_from_as_name+"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_as_names[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.import_from_as_name+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_from_as_name: NAME ['as' NAME]
static alias_ty
import_from_as_name_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    alias_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME ['as' NAME]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_as_name[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME ['as' NAME]"));
        expr_ty a;
        void *b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = _tmp_35_rule(p), !p->error_indicator)  // ['as' NAME]
        )
        {
            D(fprintf(stderr, "%*c+ import_from_as_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME ['as' NAME]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_alias ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Name . id : NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_as_name[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME ['as' NAME]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// dotted_as_names: ','.dotted_as_name+
static asdl_alias_seq*
dotted_as_names_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_alias_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.dotted_as_name+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dotted_as_names[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.dotted_as_name+"));
        asdl_alias_seq* a;
        if (
            (a = (asdl_alias_seq*)_gather_36_rule(p))  // ','.dotted_as_name+
        )
        {
            D(fprintf(stderr, "%*c+ dotted_as_names[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.dotted_as_name+"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dotted_as_names[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.dotted_as_name+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// dotted_as_name: dotted_name ['as' NAME]
static alias_ty
dotted_as_name_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    alias_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // dotted_name ['as' NAME]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dotted_as_name[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "dotted_name ['as' NAME]"));
        expr_ty a;
        void *b;
        if (
            (a = dotted_name_rule(p))  // dotted_name
            &&
            (b = _tmp_38_rule(p), !p->error_indicator)  // ['as' NAME]
        )
        {
            D(fprintf(stderr, "%*c+ dotted_as_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "dotted_name ['as' NAME]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_alias ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Name . id : NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dotted_as_name[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "dotted_name ['as' NAME]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// dotted_name: dotted_name '.' NAME | NAME
static expr_ty dotted_name_raw(Parser *);
static expr_ty
dotted_name_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, dotted_name_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_0 = _PyPegen_update_memo(p, _mark, dotted_name_type, _res);
        if (tmpvar_0) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = dotted_name_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
dotted_name_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // dotted_name '.' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dotted_name[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "dotted_name '.' NAME"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = dotted_name_rule(p))  // dotted_name
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ dotted_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "dotted_name '.' NAME"));
            _res = _PyPegen_join_names_with_dot ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dotted_name[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "dotted_name '.' NAME"));
    }
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dotted_name[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME"));
        expr_ty name_var;
        if (
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ dotted_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME"));
            _res = name_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dotted_name[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// if_stmt:
//     | invalid_if_stmt
//     | 'if' named_expression ':' block elif_stmt
//     | 'if' named_expression ':' block else_block?
static stmt_ty
if_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_if_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> if_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_if_stmt"));
        void *invalid_if_stmt_var;
        if (
            (invalid_if_stmt_var = invalid_if_stmt_rule(p))  // invalid_if_stmt
        )
        {
            D(fprintf(stderr, "%*c+ if_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_if_stmt"));
            _res = invalid_if_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s if_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_if_stmt"));
    }
    { // 'if' named_expression ':' block elif_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> if_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'if' named_expression ':' block elif_stmt"));
        Token * _keyword;
        Token * _literal;
        expr_ty a;
        asdl_stmt_seq* b;
        stmt_ty c;
        if (
            (_keyword = _PyPegen_expect_token(p, 510))  // token='if'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (c = elif_stmt_rule(p))  // elif_stmt
        )
        {
            D(fprintf(stderr, "%*c+ if_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'if' named_expression ':' block elif_stmt"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( a , b , CHECK ( asdl_stmt_seq * , _PyPegen_singleton_seq ( p , c ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s if_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'if' named_expression ':' block elif_stmt"));
    }
    { // 'if' named_expression ':' block else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> if_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'if' named_expression ':' block else_block?"));
        Token * _keyword;
        Token * _literal;
        expr_ty a;
        asdl_stmt_seq* b;
        void *c;
        if (
            (_keyword = _PyPegen_expect_token(p, 510))  // token='if'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (c = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ if_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'if' named_expression ':' block else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s if_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'if' named_expression ':' block else_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// elif_stmt:
//     | invalid_elif_stmt
//     | 'elif' named_expression ':' block elif_stmt
//     | 'elif' named_expression ':' block else_block?
static stmt_ty
elif_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_elif_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> elif_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_elif_stmt"));
        void *invalid_elif_stmt_var;
        if (
            (invalid_elif_stmt_var = invalid_elif_stmt_rule(p))  // invalid_elif_stmt
        )
        {
            D(fprintf(stderr, "%*c+ elif_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_elif_stmt"));
            _res = invalid_elif_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s elif_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_elif_stmt"));
    }
    { // 'elif' named_expression ':' block elif_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> elif_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'elif' named_expression ':' block elif_stmt"));
        Token * _keyword;
        Token * _literal;
        expr_ty a;
        asdl_stmt_seq* b;
        stmt_ty c;
        if (
            (_keyword = _PyPegen_expect_token(p, 515))  // token='elif'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (c = elif_stmt_rule(p))  // elif_stmt
        )
        {
            D(fprintf(stderr, "%*c+ elif_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'elif' named_expression ':' block elif_stmt"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( a , b , CHECK ( asdl_stmt_seq * , _PyPegen_singleton_seq ( p , c ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s elif_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'elif' named_expression ':' block elif_stmt"));
    }
    { // 'elif' named_expression ':' block else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> elif_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'elif' named_expression ':' block else_block?"));
        Token * _keyword;
        Token * _literal;
        expr_ty a;
        asdl_stmt_seq* b;
        void *c;
        if (
            (_keyword = _PyPegen_expect_token(p, 515))  // token='elif'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (c = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ elif_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'elif' named_expression ':' block else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s elif_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'elif' named_expression ':' block else_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// else_block: invalid_else_stmt | 'else' &&':' block
static asdl_stmt_seq*
else_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_else_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> else_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_else_stmt"));
        void *invalid_else_stmt_var;
        if (
            (invalid_else_stmt_var = invalid_else_stmt_rule(p))  // invalid_else_stmt
        )
        {
            D(fprintf(stderr, "%*c+ else_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_else_stmt"));
            _res = invalid_else_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s else_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_else_stmt"));
    }
    { // 'else' &&':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> else_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'else' &&':' block"));
        Token * _keyword;
        Token * _literal;
        asdl_stmt_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 516))  // token='else'
            &&
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ else_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'else' &&':' block"));
            _res = b;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s else_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'else' &&':' block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// while_stmt: invalid_while_stmt | 'while' named_expression ':' block else_block?
static stmt_ty
while_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_while_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> while_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_while_stmt"));
        void *invalid_while_stmt_var;
        if (
            (invalid_while_stmt_var = invalid_while_stmt_rule(p))  // invalid_while_stmt
        )
        {
            D(fprintf(stderr, "%*c+ while_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_while_stmt"));
            _res = invalid_while_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s while_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_while_stmt"));
    }
    { // 'while' named_expression ':' block else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> while_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'while' named_expression ':' block else_block?"));
        Token * _keyword;
        Token * _literal;
        expr_ty a;
        asdl_stmt_seq* b;
        void *c;
        if (
            (_keyword = _PyPegen_expect_token(p, 512))  // token='while'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (c = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ while_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'while' named_expression ':' block else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_While ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s while_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'while' named_expression ':' block else_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// for_stmt:
//     | invalid_for_stmt
//     | 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
//     | ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
//     | invalid_for_target
static stmt_ty
for_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_for_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_for_stmt"));
        void *invalid_for_stmt_var;
        if (
            (invalid_for_stmt_var = invalid_for_stmt_rule(p))  // invalid_for_stmt
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_for_stmt"));
            _res = invalid_for_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_for_stmt"));
    }
    { // 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        asdl_stmt_seq* b;
        void *el;
        expr_ty ex;
        expr_ty t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 517))  // token='for'
            &&
            (t = star_targets_rule(p))  // star_targets
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 518))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (ex = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_rule(p))  // block
            &&
            (el = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_For ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        Token * async_var;
        asdl_stmt_seq* b;
        void *el;
        expr_ty ex;
        expr_ty t;
        void *tc;
        if (
            (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
            &&
            (_keyword = _PyPegen_expect_token(p, 517))  // token='for'
            &&
            (t = star_targets_rule(p))  // star_targets
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 518))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (ex = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_rule(p))  // block
            &&
            (el = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 5 , "Async for loops are" , _PyAST_AsyncFor ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    if (p->call_invalid_rules) { // invalid_for_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_for_target"));
        void *invalid_for_target_var;
        if (
            (invalid_for_target_var = invalid_for_target_rule(p))  // invalid_for_target
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_for_target"));
            _res = invalid_for_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_for_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// with_stmt:
//     | invalid_with_stmt_indent
//     | 'with' '(' ','.with_item+ ','? ')' ':' block
//     | 'with' ','.with_item+ ':' TYPE_COMMENT? block
//     | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block
//     | ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block
//     | invalid_with_stmt
static stmt_ty
with_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_with_stmt_indent
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_with_stmt_indent"));
        void *invalid_with_stmt_indent_var;
        if (
            (invalid_with_stmt_indent_var = invalid_with_stmt_indent_rule(p))  // invalid_with_stmt_indent
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_with_stmt_indent"));
            _res = invalid_with_stmt_indent_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_with_stmt_indent"));
    }
    { // 'with' '(' ','.with_item+ ','? ')' ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'with' '(' ','.with_item+ ','? ')' ':' block"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 519))  // token='with'
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = (asdl_withitem_seq*)_gather_39_rule(p))  // ','.with_item+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (_literal_2 = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'with' '(' ','.with_item+ ','? ')' ':' block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 9 , "Parenthesized context managers are" , _PyAST_With ( a , b , NULL , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'with' '(' ','.with_item+ ','? ')' ':' block"));
    }
    { // 'with' ','.with_item+ ':' TYPE_COMMENT? block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'with' ','.with_item+ ':' TYPE_COMMENT? block"));
        Token * _keyword;
        Token * _literal;
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 519))  // token='with'
            &&
            (a = (asdl_withitem_seq*)_gather_41_rule(p))  // ','.with_item+
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'with' ','.with_item+ ':' TYPE_COMMENT? block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_With ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'with' ','.with_item+ ':' TYPE_COMMENT? block"));
    }
    { // ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_withitem_seq* a;
        Token * async_var;
        asdl_stmt_seq* b;
        if (
            (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
            &&
            (_keyword = _PyPegen_expect_token(p, 519))  // token='with'
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = (asdl_withitem_seq*)_gather_43_rule(p))  // ','.with_item+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (_literal_2 = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 5 , "Async with statements are" , _PyAST_AsyncWith ( a , b , NULL , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block"));
    }
    { // ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block"));
        Token * _keyword;
        Token * _literal;
        asdl_withitem_seq* a;
        Token * async_var;
        asdl_stmt_seq* b;
        void *tc;
        if (
            (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
            &&
            (_keyword = _PyPegen_expect_token(p, 519))  // token='with'
            &&
            (a = (asdl_withitem_seq*)_gather_45_rule(p))  // ','.with_item+
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 5 , "Async with statements are" , _PyAST_AsyncWith ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block"));
    }
    if (p->call_invalid_rules) { // invalid_with_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_with_stmt"));
        void *invalid_with_stmt_var;
        if (
            (invalid_with_stmt_var = invalid_with_stmt_rule(p))  // invalid_with_stmt
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_with_stmt"));
            _res = invalid_with_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_with_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// with_item:
//     | expression 'as' star_target &(',' | ')' | ':')
//     | invalid_with_item
//     | expression
static withitem_ty
with_item_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    withitem_ty _res = NULL;
    int _mark = p->mark;
    { // expression 'as' star_target &(',' | ')' | ':')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_item[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression 'as' star_target &(',' | ')' | ':')"));
        Token * _keyword;
        expr_ty e;
        expr_ty t;
        if (
            (e = expression_rule(p))  // expression
            &&
            (_keyword = _PyPegen_expect_token(p, 520))  // token='as'
            &&
            (t = star_target_rule(p))  // star_target
            &&
            _PyPegen_lookahead(1, _tmp_47_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ with_item[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression 'as' star_target &(',' | ')' | ':')"));
            _res = _PyAST_withitem ( e , t , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_item[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression 'as' star_target &(',' | ')' | ':')"));
    }
    if (p->call_invalid_rules) { // invalid_with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_item[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_with_item"));
        void *invalid_with_item_var;
        if (
            (invalid_with_item_var = invalid_with_item_rule(p))  // invalid_with_item
        )
        {
            D(fprintf(stderr, "%*c+ with_item[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_with_item"));
            _res = invalid_with_item_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_item[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_with_item"));
    }
    { // expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_item[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression"));
        expr_ty e;
        if (
            (e = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ with_item[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression"));
            _res = _PyAST_withitem ( e , NULL , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_item[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// try_stmt:
//     | invalid_try_stmt
//     | 'try' &&':' block finally_block
//     | 'try' &&':' block except_block+ else_block? finally_block?
static stmt_ty
try_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_try_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_try_stmt"));
        void *invalid_try_stmt_var;
        if (
            (invalid_try_stmt_var = invalid_try_stmt_rule(p))  // invalid_try_stmt
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_try_stmt"));
            _res = invalid_try_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_try_stmt"));
    }
    { // 'try' &&':' block finally_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'try' &&':' block finally_block"));
        Token * _keyword;
        Token * _literal;
        asdl_stmt_seq* b;
        asdl_stmt_seq* f;
        if (
            (_keyword = _PyPegen_expect_token(p, 511))  // token='try'
            &&
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (f = finally_block_rule(p))  // finally_block
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'try' &&':' block finally_block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Try ( b , NULL , NULL , f , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'try' &&':' block finally_block"));
    }
    { // 'try' &&':' block except_block+ else_block? finally_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'try' &&':' block except_block+ else_block? finally_block?"));
        Token * _keyword;
        Token * _literal;
        asdl_stmt_seq* b;
        void *el;
        asdl_excepthandler_seq* ex;
        void *f;
        if (
            (_keyword = _PyPegen_expect_token(p, 511))  // token='try'
            &&
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (ex = (asdl_excepthandler_seq*)_loop1_48_rule(p))  // except_block+
            &&
            (el = else_block_rule(p), !p->error_indicator)  // else_block?
            &&
            (f = finally_block_rule(p), !p->error_indicator)  // finally_block?
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'try' &&':' block except_block+ else_block? finally_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Try ( b , ex , el , f , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'try' &&':' block except_block+ else_block? finally_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// except_block:
//     | invalid_except_stmt_indent
//     | 'except' expression ['as' NAME] ':' block
//     | 'except' ':' block
//     | invalid_except_stmt
static excepthandler_ty
except_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    excepthandler_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_except_stmt_indent
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_except_stmt_indent"));
        void *invalid_except_stmt_indent_var;
        if (
            (invalid_except_stmt_indent_var = invalid_except_stmt_indent_rule(p))  // invalid_except_stmt_indent
        )
        {
            D(fprintf(stderr, "%*c+ except_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_except_stmt_indent"));
            _res = invalid_except_stmt_indent_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_except_stmt_indent"));
    }
    { // 'except' expression ['as' NAME] ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'except' expression ['as' NAME] ':' block"));
        Token * _keyword;
        Token * _literal;
        asdl_stmt_seq* b;
        expr_ty e;
        void *t;
        if (
            (_keyword = _PyPegen_expect_token(p, 521))  // token='except'
            &&
            (e = expression_rule(p))  // expression
            &&
            (t = _tmp_49_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ except_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'except' expression ['as' NAME] ':' block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ExceptHandler ( e , ( t ) ? ( ( expr_ty ) t ) -> v . Name . id : NULL , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'except' expression ['as' NAME] ':' block"));
    }
    { // 'except' ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'except' ':' block"));
        Token * _keyword;
        Token * _literal;
        asdl_stmt_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 521))  // token='except'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ except_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'except' ':' block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ExceptHandler ( NULL , NULL , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'except' ':' block"));
    }
    if (p->call_invalid_rules) { // invalid_except_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_except_stmt"));
        void *invalid_except_stmt_var;
        if (
            (invalid_except_stmt_var = invalid_except_stmt_rule(p))  // invalid_except_stmt
        )
        {
            D(fprintf(stderr, "%*c+ except_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_except_stmt"));
            _res = invalid_except_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_except_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// finally_block: invalid_finally_stmt | 'finally' &&':' block
static asdl_stmt_seq*
finally_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_finally_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> finally_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_finally_stmt"));
        void *invalid_finally_stmt_var;
        if (
            (invalid_finally_stmt_var = invalid_finally_stmt_rule(p))  // invalid_finally_stmt
        )
        {
            D(fprintf(stderr, "%*c+ finally_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_finally_stmt"));
            _res = invalid_finally_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s finally_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_finally_stmt"));
    }
    { // 'finally' &&':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> finally_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'finally' &&':' block"));
        Token * _keyword;
        Token * _literal;
        asdl_stmt_seq* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 522))  // token='finally'
            &&
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (a = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ finally_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'finally' &&':' block"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s finally_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'finally' &&':' block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// match_stmt:
//     | "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT
//     | invalid_match_stmt
static stmt_ty
match_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> match_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "\"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT"));
        expr_ty _keyword;
        Token * _literal;
        asdl_match_case_seq* cases;
        Token * dedent_var;
        Token * indent_var;
        Token * newline_var;
        expr_ty subject;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "match"))  // soft_keyword='"match"'
            &&
            (subject = subject_expr_rule(p))  // subject_expr
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (indent_var = _PyPegen_expect_token(p, INDENT))  // token='INDENT'
            &&
            (cases = (asdl_match_case_seq*)_loop1_50_rule(p))  // case_block+
            &&
            (dedent_var = _PyPegen_expect_token(p, DEDENT))  // token='DEDENT'
        )
        {
            D(fprintf(stderr, "%*c+ match_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "\"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 10 , "Pattern matching is" , _PyAST_Match ( subject , cases , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s match_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "\"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT"));
    }
    if (p->call_invalid_rules) { // invalid_match_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> match_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_match_stmt"));
        void *invalid_match_stmt_var;
        if (
            (invalid_match_stmt_var = invalid_match_stmt_rule(p))  // invalid_match_stmt
        )
        {
            D(fprintf(stderr, "%*c+ match_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_match_stmt"));
            _res = invalid_match_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s match_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_match_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// subject_expr: star_named_expression ',' star_named_expressions? | named_expression
static expr_ty
subject_expr_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // star_named_expression ',' star_named_expressions?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> subject_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_named_expression ',' star_named_expressions?"));
        Token * _literal;
        expr_ty value;
        void *values;
        if (
            (value = star_named_expression_rule(p))  // star_named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (values = star_named_expressions_rule(p), !p->error_indicator)  // star_named_expressions?
        )
        {
            D(fprintf(stderr, "%*c+ subject_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_named_expression ',' star_named_expressions?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Tuple ( CHECK ( asdl_expr_seq * , _PyPegen_seq_insert_in_front ( p , value , values ) ) , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s subject_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_named_expression ',' star_named_expressions?"));
    }
    { // named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> subject_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "named_expression"));
        expr_ty named_expression_var;
        if (
            (named_expression_var = named_expression_rule(p))  // named_expression
        )
        {
            D(fprintf(stderr, "%*c+ subject_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "named_expression"));
            _res = named_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s subject_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "named_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// case_block: invalid_case_block | "case" patterns guard? ':' block
static match_case_ty
case_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    match_case_ty _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_case_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> case_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_case_block"));
        void *invalid_case_block_var;
        if (
            (invalid_case_block_var = invalid_case_block_rule(p))  // invalid_case_block
        )
        {
            D(fprintf(stderr, "%*c+ case_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_case_block"));
            _res = invalid_case_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s case_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_case_block"));
    }
    { // "case" patterns guard? ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> case_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "\"case\" patterns guard? ':' block"));
        expr_ty _keyword;
        Token * _literal;
        asdl_stmt_seq* body;
        void *guard;
        pattern_ty pattern;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "case"))  // soft_keyword='"case"'
            &&
            (pattern = patterns_rule(p))  // patterns
            &&
            (guard = guard_rule(p), !p->error_indicator)  // guard?
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (body = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ case_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "\"case\" patterns guard? ':' block"));
            _res = _PyAST_match_case ( pattern , guard , body , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s case_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "\"case\" patterns guard? ':' block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// guard: 'if' named_expression
static expr_ty
guard_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // 'if' named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> guard[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'if' named_expression"));
        Token * _keyword;
        expr_ty guard;
        if (
            (_keyword = _PyPegen_expect_token(p, 510))  // token='if'
            &&
            (guard = named_expression_rule(p))  // named_expression
        )
        {
            D(fprintf(stderr, "%*c+ guard[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'if' named_expression"));
            _res = guard;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s guard[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'if' named_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// patterns: open_sequence_pattern | pattern
static pattern_ty
patterns_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // open_sequence_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> patterns[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "open_sequence_pattern"));
        asdl_pattern_seq* patterns;
        if (
            (patterns = (asdl_pattern_seq*)open_sequence_pattern_rule(p))  // open_sequence_pattern
        )
        {
            D(fprintf(stderr, "%*c+ patterns[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "open_sequence_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchSequence ( patterns , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s patterns[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "open_sequence_pattern"));
    }
    { // pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> patterns[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "pattern"));
        pattern_ty pattern_var;
        if (
            (pattern_var = pattern_rule(p))  // pattern
        )
        {
            D(fprintf(stderr, "%*c+ patterns[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "pattern"));
            _res = pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s patterns[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// pattern: as_pattern | or_pattern
static pattern_ty
pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    { // as_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "as_pattern"));
        pattern_ty as_pattern_var;
        if (
            (as_pattern_var = as_pattern_rule(p))  // as_pattern
        )
        {
            D(fprintf(stderr, "%*c+ pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "as_pattern"));
            _res = as_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "as_pattern"));
    }
    { // or_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "or_pattern"));
        pattern_ty or_pattern_var;
        if (
            (or_pattern_var = or_pattern_rule(p))  // or_pattern
        )
        {
            D(fprintf(stderr, "%*c+ pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "or_pattern"));
            _res = or_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "or_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// as_pattern: or_pattern 'as' pattern_capture_target | invalid_as_pattern
static pattern_ty
as_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // or_pattern 'as' pattern_capture_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> as_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "or_pattern 'as' pattern_capture_target"));
        Token * _keyword;
        pattern_ty pattern;
        expr_ty target;
        if (
            (pattern = or_pattern_rule(p))  // or_pattern
            &&
            (_keyword = _PyPegen_expect_token(p, 520))  // token='as'
            &&
            (target = pattern_capture_target_rule(p))  // pattern_capture_target
        )
        {
            D(fprintf(stderr, "%*c+ as_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "or_pattern 'as' pattern_capture_target"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchAs ( pattern , target -> v . Name . id , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s as_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "or_pattern 'as' pattern_capture_target"));
    }
    if (p->call_invalid_rules) { // invalid_as_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> as_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_as_pattern"));
        void *invalid_as_pattern_var;
        if (
            (invalid_as_pattern_var = invalid_as_pattern_rule(p))  // invalid_as_pattern
        )
        {
            D(fprintf(stderr, "%*c+ as_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_as_pattern"));
            _res = invalid_as_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s as_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_as_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// or_pattern: '|'.closed_pattern+
static pattern_ty
or_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '|'.closed_pattern+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> or_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'|'.closed_pattern+"));
        asdl_pattern_seq* patterns;
        if (
            (patterns = (asdl_pattern_seq*)_gather_51_rule(p))  // '|'.closed_pattern+
        )
        {
            D(fprintf(stderr, "%*c+ or_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'|'.closed_pattern+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = asdl_seq_LEN ( patterns ) == 1 ? asdl_seq_GET ( patterns , 0 ) : _PyAST_MatchOr ( patterns , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s or_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'|'.closed_pattern+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// closed_pattern:
//     | literal_pattern
//     | capture_pattern
//     | wildcard_pattern
//     | value_pattern
//     | group_pattern
//     | sequence_pattern
//     | mapping_pattern
//     | class_pattern
static pattern_ty
closed_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    if (_PyPegen_is_memoized(p, closed_pattern_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    { // literal_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "literal_pattern"));
        pattern_ty literal_pattern_var;
        if (
            (literal_pattern_var = literal_pattern_rule(p))  // literal_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "literal_pattern"));
            _res = literal_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "literal_pattern"));
    }
    { // capture_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "capture_pattern"));
        pattern_ty capture_pattern_var;
        if (
            (capture_pattern_var = capture_pattern_rule(p))  // capture_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "capture_pattern"));
            _res = capture_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "capture_pattern"));
    }
    { // wildcard_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "wildcard_pattern"));
        pattern_ty wildcard_pattern_var;
        if (
            (wildcard_pattern_var = wildcard_pattern_rule(p))  // wildcard_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "wildcard_pattern"));
            _res = wildcard_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "wildcard_pattern"));
    }
    { // value_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "value_pattern"));
        pattern_ty value_pattern_var;
        if (
            (value_pattern_var = value_pattern_rule(p))  // value_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "value_pattern"));
            _res = value_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "value_pattern"));
    }
    { // group_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "group_pattern"));
        pattern_ty group_pattern_var;
        if (
            (group_pattern_var = group_pattern_rule(p))  // group_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "group_pattern"));
            _res = group_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "group_pattern"));
    }
    { // sequence_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "sequence_pattern"));
        pattern_ty sequence_pattern_var;
        if (
            (sequence_pattern_var = sequence_pattern_rule(p))  // sequence_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "sequence_pattern"));
            _res = sequence_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "sequence_pattern"));
    }
    { // mapping_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "mapping_pattern"));
        pattern_ty mapping_pattern_var;
        if (
            (mapping_pattern_var = mapping_pattern_rule(p))  // mapping_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "mapping_pattern"));
            _res = mapping_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "mapping_pattern"));
    }
    { // class_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "class_pattern"));
        pattern_ty class_pattern_var;
        if (
            (class_pattern_var = class_pattern_rule(p))  // class_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "class_pattern"));
            _res = class_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "class_pattern"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, closed_pattern_type, _res);
    p->level--;
    return _res;
}

// literal_pattern:
//     | signed_number !('+' | '-')
//     | complex_number
//     | strings
//     | 'None'
//     | 'True'
//     | 'False'
static pattern_ty
literal_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // signed_number !('+' | '-')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "signed_number !('+' | '-')"));
        expr_ty value;
        if (
            (value = signed_number_rule(p))  // signed_number
            &&
            _PyPegen_lookahead(0, _tmp_53_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "signed_number !('+' | '-')"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchValue ( value , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "signed_number !('+' | '-')"));
    }
    { // complex_number
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "complex_number"));
        expr_ty value;
        if (
            (value = complex_number_rule(p))  // complex_number
        )
        {
            D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "complex_number"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchValue ( value , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "complex_number"));
    }
    { // strings
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "strings"));
        expr_ty value;
        if (
            (value = strings_rule(p))  // strings
        )
        {
            D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "strings"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchValue ( value , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "strings"));
    }
    { // 'None'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'None'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 523))  // token='None'
        )
        {
            D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'None'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchSingleton ( Py_None , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'None'"));
    }
    { // 'True'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'True'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 524))  // token='True'
        )
        {
            D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'True'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchSingleton ( Py_True , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'True'"));
    }
    { // 'False'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'False'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 525))  // token='False'
        )
        {
            D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'False'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchSingleton ( Py_False , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'False'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// literal_expr:
//     | signed_number !('+' | '-')
//     | complex_number
//     | strings
//     | 'None'
//     | 'True'
//     | 'False'
static expr_ty
literal_expr_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // signed_number !('+' | '-')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "signed_number !('+' | '-')"));
        expr_ty signed_number_var;
        if (
            (signed_number_var = signed_number_rule(p))  // signed_number
            &&
            _PyPegen_lookahead(0, _tmp_54_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ literal_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "signed_number !('+' | '-')"));
            _res = signed_number_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "signed_number !('+' | '-')"));
    }
    { // complex_number
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "complex_number"));
        expr_ty complex_number_var;
        if (
            (complex_number_var = complex_number_rule(p))  // complex_number
        )
        {
            D(fprintf(stderr, "%*c+ literal_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "complex_number"));
            _res = complex_number_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "complex_number"));
    }
    { // strings
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "strings"));
        expr_ty strings_var;
        if (
            (strings_var = strings_rule(p))  // strings
        )
        {
            D(fprintf(stderr, "%*c+ literal_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "strings"));
            _res = strings_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "strings"));
    }
    { // 'None'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'None'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 523))  // token='None'
        )
        {
            D(fprintf(stderr, "%*c+ literal_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'None'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_None , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'None'"));
    }
    { // 'True'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'True'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 524))  // token='True'
        )
        {
            D(fprintf(stderr, "%*c+ literal_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'True'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_True , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'True'"));
    }
    { // 'False'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'False'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 525))  // token='False'
        )
        {
            D(fprintf(stderr, "%*c+ literal_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'False'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_False , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'False'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// complex_number:
//     | signed_real_number '+' imaginary_number
//     | signed_real_number '-' imaginary_number
static expr_ty
complex_number_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // signed_real_number '+' imaginary_number
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> complex_number[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "signed_real_number '+' imaginary_number"));
        Token * _literal;
        expr_ty imag;
        expr_ty real;
        if (
            (real = signed_real_number_rule(p))  // signed_real_number
            &&
            (_literal = _PyPegen_expect_token(p, 14))  // token='+'
            &&
            (imag = imaginary_number_rule(p))  // imaginary_number
        )
        {
            D(fprintf(stderr, "%*c+ complex_number[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "signed_real_number '+' imaginary_number"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( real , Add , imag , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s complex_number[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "signed_real_number '+' imaginary_number"));
    }
    { // signed_real_number '-' imaginary_number
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> complex_number[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "signed_real_number '-' imaginary_number"));
        Token * _literal;
        expr_ty imag;
        expr_ty real;
        if (
            (real = signed_real_number_rule(p))  // signed_real_number
            &&
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (imag = imaginary_number_rule(p))  // imaginary_number
        )
        {
            D(fprintf(stderr, "%*c+ complex_number[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "signed_real_number '-' imaginary_number"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( real , Sub , imag , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s complex_number[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "signed_real_number '-' imaginary_number"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// signed_number: NUMBER | '-' NUMBER
static expr_ty
signed_number_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NUMBER
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> signed_number[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NUMBER"));
        expr_ty number_var;
        if (
            (number_var = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ signed_number[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NUMBER"));
            _res = number_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s signed_number[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NUMBER"));
    }
    { // '-' NUMBER
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> signed_number[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'-' NUMBER"));
        Token * _literal;
        expr_ty number;
        if (
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (number = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ signed_number[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'-' NUMBER"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( USub , number , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s signed_number[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'-' NUMBER"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// signed_real_number: real_number | '-' real_number
static expr_ty
signed_real_number_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // real_number
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> signed_real_number[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "real_number"));
        expr_ty real_number_var;
        if (
            (real_number_var = real_number_rule(p))  // real_number
        )
        {
            D(fprintf(stderr, "%*c+ signed_real_number[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "real_number"));
            _res = real_number_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s signed_real_number[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "real_number"));
    }
    { // '-' real_number
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> signed_real_number[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'-' real_number"));
        Token * _literal;
        expr_ty real;
        if (
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (real = real_number_rule(p))  // real_number
        )
        {
            D(fprintf(stderr, "%*c+ signed_real_number[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'-' real_number"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( USub , real , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s signed_real_number[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'-' real_number"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// real_number: NUMBER
static expr_ty
real_number_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // NUMBER
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> real_number[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NUMBER"));
        expr_ty real;
        if (
            (real = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ real_number[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NUMBER"));
            _res = _PyPegen_ensure_real ( p , real );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s real_number[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NUMBER"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// imaginary_number: NUMBER
static expr_ty
imaginary_number_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // NUMBER
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> imaginary_number[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NUMBER"));
        expr_ty imag;
        if (
            (imag = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ imaginary_number[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NUMBER"));
            _res = _PyPegen_ensure_imaginary ( p , imag );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s imaginary_number[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NUMBER"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// capture_pattern: pattern_capture_target
static pattern_ty
capture_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // pattern_capture_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> capture_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "pattern_capture_target"));
        expr_ty target;
        if (
            (target = pattern_capture_target_rule(p))  // pattern_capture_target
        )
        {
            D(fprintf(stderr, "%*c+ capture_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "pattern_capture_target"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchAs ( NULL , target -> v . Name . id , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s capture_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "pattern_capture_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// pattern_capture_target: !"_" NAME !('.' | '(' | '=')
static expr_ty
pattern_capture_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // !"_" NAME !('.' | '(' | '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> pattern_capture_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "!\"_\" NAME !('.' | '(' | '=')"));
        expr_ty name;
        if (
            _PyPegen_lookahead_with_string(0, _PyPegen_expect_soft_keyword, p, "_")
            &&
            (name = _PyPegen_name_token(p))  // NAME
            &&
            _PyPegen_lookahead(0, _tmp_55_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ pattern_capture_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "!\"_\" NAME !('.' | '(' | '=')"));
            _res = _PyPegen_set_expr_context ( p , name , Store );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s pattern_capture_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "!\"_\" NAME !('.' | '(' | '=')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// wildcard_pattern: "_"
static pattern_ty
wildcard_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // "_"
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> wildcard_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "\"_\""));
        expr_ty _keyword;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "_"))  // soft_keyword='"_"'
        )
        {
            D(fprintf(stderr, "%*c+ wildcard_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "\"_\""));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchAs ( NULL , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s wildcard_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "\"_\""));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// value_pattern: attr !('.' | '(' | '=')
static pattern_ty
value_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // attr !('.' | '(' | '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> value_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "attr !('.' | '(' | '=')"));
        expr_ty attr;
        if (
            (attr = attr_rule(p))  // attr
            &&
            _PyPegen_lookahead(0, _tmp_56_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ value_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "attr !('.' | '(' | '=')"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchValue ( attr , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s value_pattern[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "attr !('.' | '(' | '=')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// attr: name_or_attr '.' NAME
static expr_ty attr_raw(Parser *);
sta